DEC64: Decimal Floating Point

This library contains initial attempts to port the brilliant work of *Douglas Crockford* [ML64](https://msdn.microsoft.com/en-us/library/hb5z4sxd.aspx) (Windows/Intel MASM assembler).

```
; This file can be processed with Microsoft's ML64.exe. There might be other
; assemblers that can process this file, but that has not been tested.
```

## How to port to Javascript?

I think the excellent [Fraction.js](https://github.com/infusion/Fraction.js) could be a good start to approximate the precision of DEC64.

Another approach is to find the [mantisse and exponent of a number](http://stackoverflow.com/posts/30690986/edit) where `b` (base) is 10.

The `mantissa` is the number of digits of a floating-point number before the exponent or exponential expression.

For the number `2.9979 · 10^8` the mantissa is: `2.9979`. The `exponent` would be the (10 to the power of) `8` ie. the degree to which it is raised high or low.

```js
function numberParts(x, b) {
  var exp = 0
  var sgn = 0
    if (x === 0) return { sign: 0, mantissa: 0, exponent: 0 }
  if (x<0) sgn=1, x=-x
    while (x>b) x/=b, exp++
  while (x<1) x*=b, exp--
  return { sign: sgn, mantissa: x, exponent: exp }
}
```

For Integers, simply shift left by 8(ie. convert to bitmap and put full number in `coefficient`). For Floats, calculate the `mantisse` and `exponent`.

Then convert the Float it to a bitmap and right shift by exponent to get its equivalent as an integer. Insert it like before (shift left 8 bits or insert it directly into coefficient) and then store the `exponent` in the exponent. Make sure the last bit (most left) of the coefficient indicates the sign of the number (ie bit 64). The last bit of the coefficient should indicate the sign of the coefficient (ie. very low or very high number).

From there on you should hopefully be able to convert the C to JavaScript, either manually or via some kind of compiler.

For some adventures in Assembly Compiler land (Max OSX), see the notes at the end

## Credits

```
Douglas Crockford
douglas@crockford.com
```

```
dec64.com
2017-01-22
Public Domain
```

```
    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
    SUBJECT TO CHANGE WITHOUT NOTICE.
```

`DEC64` is a decimal floating point format for the next generation of
application programming languages.

`dec64.asm` is an implementation of the elementary operators for x64, including
    coefficient exponent equal is_any_nan is_integer is_zero less
    abs add ceiling dec divide floor half inc int integer_divide modulo
    multiply neg new normal not round signum subtract

`dec64.asm.html` is a description of the functions in dec64.asm.

`dec64.h` is a companion header file for C.

`dec64_test.c` is a test program.

`dec64_string.c` is an implementation of functions for converting between DEC64
and strings.

`dec64_string.html` is a description of the functions in dec64_string.c.

`dec64_string.h` is a companion header file.

`dec64_string_test.c` is a test program.


`dec64_math.c` is a placeholder implementation of elementary functions, including

```
    acos    asin    atan    atan2    cos    exp      factorial
    log     raise   root    sin      sqrt   tan
```

and

```

`    random  seed`

`dec64_math.html is a description of the functions in dec64_math.h.`

`dec64_math.h` is a companion header file.

`dec64_math_test.c` is a test program.

`dec64.html` is a descriptive web page.

`dec64.png` is a logo.

###

## Cross platform compilation/debugging!?

We would like to convert it to NASM (Unix Assembly) and in the end to an executable (.exe) and JavaScript. Unfortunately I'm not on a Windows PC but on a Mac.

A solution could be to try running `ML64.exe` compiler on Mac via [Wine](https://www.winehq.org/) or similar compatibility layer.

You could also try [MASM_OSX](https://github.com/janka102/MASM_OSX) to use Xcode or Visual Studio Code (VSC) to edit, compile, and debug MASM files. 

I was able to build the following example from Xcode

```
TITLE MASM Template       (main.asm)

; Description:
; 
; Revision date:

INCLUDE Irvine32.inc

.data
myMessage BYTE "MASM program example",0dh,0ah,0

.code
main PROC
    call Clrscr

    mov  edx,OFFSET myMessage
    call WriteString

    exit
main ENDP

END main
```

Which I could then execute from terminal and it printed `MASM program example`

```
$ ./bin/template
MASM program example
```

Looks promising!

So far having problems with the following:

`dec64_code segment para execute`

But this works!?

`dec64_data segment para read`

Since there is a `dec64_data ends`

This fails:

```
dec64_exponent: function_with_one_parameter
  movsx   r0,r1_b             ; r0 is the exponent
```

While this will build `dec64_exponent: function_with_one_parameter`

`movsx` will compile if within an `if` clause that will be false!

```
if UNIX
movsx   r0,r1_b             ; r0 is the exponent
endif
```

Looks like there are some slight differences to be aware of! [writing-64-bit-assembly-on-mac-os-x](http://www.idryman.org/blog/2014/12/02/writing-64-bit-assembly-on-mac-os-x/)

The error is that msvsx references r0, which is defined using `rax`

As it is widely advertised, modern x86_64 processors have 64-bit registers that can be used in backward-compatible fashion as 32-bit registers, 16-bit registers and even 8-bit registers, for example:

```
0x1122334455667788
  ================ rax (64 bits)
          ======== eax (32 bits)
              ====  ax (16 bits)
              ==    ah (8 bits)
                ==  al (8 bits)
```

So it looks like I don't have the rax register available! Looks like I need to tell Xcode to [compile for x64 bit](https://metricpanda.com/compiling-nasm-with-xcode-in-a-cpp-project)

`/usr/local/bin/nasm -f macho64 ${INPUT_FILE_PATH} -o ${SCRIPT_OUTPUT_FILE_0}`

I see my Makefile uses `32`bit!

If you’d rather create a 32-bit object file, you can supply the `-arch i386` parameter which is exactly what I have:

`CFLAGS=-Wall -O0 -g -arch i386 -lAlong32 -Llib -Wl,-no_pie`

To get started on writing OSX assembly, you need to understand OSX executable file format – the Mach-O file format. It’s similar to ELF, but instead of sections of data, bss, and text, it has segments that contains sections.

[x64-osx-assembly-mov](http://stackoverflow.com/questions/26899769/x64-osx-assembly-mov)

`mov tmp, rax` is illegal because nasm requires square brackets [] around memory operands. As such, what you want is mov [tmp], rax. This is of course mentioned in the nasm manual, see the section aptly named NASM Requires Square Brackets For Memory References.


[More Assembly OSX tips](https://lord.io/blog/2014/assembly-on-osx/)


### Many more Compiler Experiments...

Try [visual MASM](http://www.visualmasm.com/)

Perhaps we could also run `ml64.exe` directly via `Wine`? Check [Microsoft Macro Assembler 8.0 (MASM) Package (x86)](https://www.microsoft.com/en-us/download/confirmation.aspx?id=12654)

I tried opening `Wine Dev` and running `wine MASMsetup.EXE` saying no to installing `Gecko` (UI). It failed with `Visual Studio EE 2005 required`. Others suggest extracting it from [Windows Driver Kit (WDK)](https://www.microsoft.com/en-us/download/details.aspx?id=11800) a 620Mb install!

Yet another option could be [mingw-w64](https://sourceforge.net/projects/mingw-w64/) - *Supports 32-bit and 64-bit Windows i386/x64* or [For darwin](http://mingw-w64.org/doku.php/download/darwin)

No luck trying to figure out how to use mingw-w64 for Windows via Wine!

There IS also a cross-platform [SASM](https://github.com/Dman95/SASM) Assembler IDE which includes [Mac OSX build instructions](http://www.brianrhall.net/rss/installingsasmonamac) and some [premade Mac builds](https://github.com/Dman95/SASM/issues/57)
I have not yet been able to make it pick up Qt however.

This conversion will allow broader usage in modern languages, such as those compiling to JavaScript, NASM, SIMD, asm.js or WASM (Web Assembly).

### Manual conversion

You could try the manual conversion using this guide: [Assembly from masm to nasm](http://left404.com/2011/01/04/converting-x86-assembly-from-masm-to-nasm-3/)

Ideally we should be able to decompile using this [recipe](http://reverseengineering.stackexchange.com/questions/10924/translate-assembly-to-c)
- [compile assembly to executable](http://www.tutorialspoint.com/compile_assembly_online.php)
- [executable to C decompiler](https://retdec.com/decompilation/)

If we ever get to a working `dec64.c` file either manually or via decompilation we could use [require-emscripten](https://www.npmjs.com/package/require-emscripten)
to convert the `.c` file to a Node JavaScript `.js` file via [Emscripten](https://github.com/kripken/emscripten)

## Mac OSX adventure

I'm giving up on my end. If anyone has a Windows out there wih Visual Studio or some other way to compile, debug and help port this lib, please do!

Thanks!